---
layout: post
title: 'Java后端面试整理（二）'
author: Marty Pang
categories: 
  - Interview
tags: 
  - Java
  - Back-End
last_modified_at: 2019-08-30T12:52:09-05:00
---

网络跟操作系统的问题也问到不少，在此也做一个总结。

* 目录
{:toc}


# 网络

1. tcp与udp区别
  udp面向无连接，没有拥塞控制，面向报文，应用层传下来的数据不拆分也不合并，添加UDP头部；tcp面向连接，流量控制与拥塞控制，面向字节流，字节流组织成大小不等的块。

2. tcp三次握手四次挥手
  （确认号为收到的序列号+1，建立连接后，ACK一直为1）
客户端A发送连接请求报文（SYN=1，ACK=0，seq=x）到服务端B，
B收到请求后，发送确认连接报文（SYN=1，ACK=1，seq=y，ack=x+1），
A再次向B发送确认报文，确认号ack为y+1，seq为x+1，
B收到A的消息后，连接建立；
![](/images/20190830/handshake.png)
客户端A发送连接释放报文，FIN设置为1，seq为x，进入FIN_WAIT1状态，
服务端回复确认消息，确认号为x+1。序列号为y，此时A进入FIN_WAIT2状态，无法发送消息，只能接收，
服务端发送未发完的数据，B不需要连接之后，发送连接释放报文给A，确认号为x+1，序列号为z，A收到后发出确认，进入TIME_WAIT状态，等待一段时间（2倍最大报文存活时间）后释放连接；
![](/images/20190830/wavehand.jpg)

3. 为什么需要三次握手？
  防止打开失效连接，如果客户端的一个连接请求超时了，客户端再发一个，最终两个请求都到达服务端，服务端会开两个连接。如果有第三次握手，A会忽略B对滞留连接请求的确认消息，B收不到A的第三次握手，故不会建立第二个连接。

4. 为什么要四次挥手？
  服务端进入CLOSE_WAIT状态，可以发送未传送完毕的数据，发送完之后再发送连接释放报文。多了一次挥手。

5. 为什么不直接进入closed状态，而是time wait？
  确保最后一个确认报文能到达B

6. tcp流量控制
  通过滑动窗口大小控制发送发的发送速率。

7. tcp拥塞控制
- 慢开始 拥塞窗口状态变量初始设置为1，每收到一个确认，翻倍；
- 拥塞避免 状态变量达到一个阈值之后，每收到一个确认+1，当出现超时，设置阈值为超时是状态变量的一半，重新慢开始；
- 快重传 接收方每次收到报文，对最后一个收到的有序报文进行确认，如果发送发连续收到三次某一个报文的确认，说明下一个报文丢失了，发送发执行快重传
- 快恢复 在这种丢失个别报文的情况下，执行快恢复，即设置阈值为当前状态变量的一半，设置当前状态变量为阈值，直接进入拥塞避免；

8. 输入url到浏览器加载的过程
- 浏览器（应用层）DNS解析：浏览器缓存，本地host，运行商DNS缓存，根域名DNS服务器，顶级域名DNS服务器，逐步读取缓存直到获取IP；
- 浏览器针对目标服务器生成HTTP请求报文，包括起始行，header和body。header包括域名，user-agent和cookie信息等；
- 传输层建立TCP连接，HTTP使用TCP来传输数据，使用本地大于1024的一个随机端口与服务器80端口建立连接，发送http请求；
- 服务端发送http响应；
- 浏览器渲染；
- 四次挥手关闭连接；

9. HTTP与HTTPS协议
  HTTP/1.1开始默认是长连接，引入cookie保存状态信息。HTTP明文通信，不互相验证身份，无法证明报文的完整性，故引入HTTPS。HTTPS使用混合加密机制，非对称加密用来传输对称密钥，之后的通信过程采用对称加密保证安全。TLS握手协议建立在TCP三次握手之上，用于客户端与服务端协商加密算法与密钥，ClientHello，ServerHello与ClientKeyExchange。HMAC保证数据完整性。
  HTTP请求包括请求行，请求头部与主体，响应包括状态行，响应头与响应主体。
  ![](/images/20190830/httprequest.png){:.align-center}
  请求行格式[方法，URI，协议/版本号]，方法包括GET，POST，PUT，DELETE等。GET与POST都能传送额外的参数，不同的是GET的参数写在请求行的URI里，POST的参数写在body里。
  ![](/images/20190830/httpresponse.png){:	.align-center}
  响应消息的状态码包括五类：

  - 1xx 接收的请求正在处理；
  - 2xx请求成功处理完毕；
  - 3xx重定向，需进行额外操作完成请求；
  - 4xx客户端错误，服务端无法解析请求；
  - 5xx服务端错误

10. nat是什么？属于哪一层？

  网络地址转换，网络层

11. 介绍一下网络分层的模型

    OSI七层网络架构：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层

    五层模型：应用层，传输层，网络层，数据链路层，物理层

12. 链路层有什么协议？


# 操作系统

1. 进程和线程的区别？
  进程是应用程序在机器上的一次执行过程，一个正在执行程序的实例；线程是进程的一个执行单元，一个进程可以拥有多个线程，线程又叫做轻量级进程。
  区别：进程有自己的独立空间，而线程共享进程的地址空间，有自己的栈和局部变量；进程是资源分配的基本单位，线程是独立调度的基本单位。线程是轻量级的进程，创建和销毁的开销小。一个进程崩溃后，不会对其他进程产生影响，一个线程死掉就等于整个进程死掉。
  
2. 如何杀死一个进程？
kill命令，发送指定信号到相应的进程，不指定信号默认为SIGTERM（15），可使用`kill -l`列出所有全部信号名称。下面列举几个常用信号：
  - SIGHUP 1 终端断线
  - SIGINT 2 终端 （Crtl+C）
  - SIGQIUT 3 退出 （Ctrl+\\）
  - SIGKILL 9 强制终止 不进行资源的清理
  - SIGTERM 15 终止，正常退出，按程序自己的退出流程，安全


3. 介绍下你理解的操作系统中线程切换过程。
  进程线程最大的区别在于，线程是调度的基本单位，而进程则是资源分配的基本单位，内核中的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。可以这么理解线程切换：
- 当线程只拥有一个线程，可以理解为任务进程就是线程；
- 若进程拥有多个线程，这些线程共享虚拟内存，全局变量，这些资源在线程上下文切换时是不需要修改的；
- 线程自己的私有数据，如程序计数器，寄存器，栈等，需要在线程上下文切换的时候保存；
  当切换的两个线程属于同一个进程时，切换时因为资源共享，只需要切换私有数据，保存寄存器程序计数器，栈等信息；而当切换的线程属于不同进程时，它们的切换就相当于进程的切换。进程间切换消耗的资源多余线程间的切换。

4. 线程的生命周期
  ![LifeCycle](/images/20190830/threadlifecycle.png){:	.align-center}
- 新建：new一个线程
- 就绪：调用Thread.start()之后，线程处于就绪状态，线程加入线程列表等待调度，之后调用本地方法采用pthread_create创建线程。
- 运行：就绪状态的线程获取CPU资源后开始执行
- 阻塞：有三种原因使得线程从运行状态到阻塞状态：a. 等待阻塞，wait()方法，线程放入等待池，释放锁；b. 同步阻塞，线程在获取对象的同步锁，若锁被占用，放入锁池中；c. 其他阻塞，sleep或者join或者IO请求，不释放持有的锁
- 死亡：run结束或者抛出未捕获的异常或者stop

5. 如何优雅地终止Java线程？
stop()方法，已被弃用，数据处理一部分就会被终止。
volatile标志位或者原子标志，run方法里加个while循环，使用一个标志位控制
使用interrupt，进一步分为有阻塞与无阻塞两种情况的中断方式：
先看无阻塞，直接while判断线程的中断情况即可，示例代码如下：
  ```java
public static void main(String[] args) throws Exception{
    Thread thread = new Thread(new Runnable() {
        @Override
        public void run() {
            while(!Thread.interrupted()) {
                //无阻塞的任务
            }
        }
    });
    thread.start();
    Thread.sleep(10);
    thread.interrupt();
}
  ```
再看任务存在阻塞逻辑的情况：
  ```java
public static void main(String[] args) throws Exception{
    Thread thread = new Thread(new Runnable() {
        @Override
        public void run() {
            while(!Thread.interrupted()) {
                //任务
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    e.printStackTrace();
                }
            }
        }
    });
    thread.start();
    Thread.sleep(50);
    thread.interrupt();
}
  ```


6. 进程的通信方式
- 最古老的方式，管道，半双工，两个描述符，fd[0]读和fd[1]写。一般pipe之后接着调用fork，创建父子进程之间的管道，在内存中申请一块固定大小的缓冲区（64kB），速度慢；
- 命名管道FIFO，任何进程之间通信，支持双向或单向，速度慢，消息长度有上限，mkfifo，管道名存放在内存，内容保存在内存中；
- 消息队列，内核中创建消息链表，每个元素是一个消息，有一个类型mtype，msgrcv有一个type参数，为0说明先进先出，返回队列第一个消息，非0，按type值取消息
- 信号量，计数器，用于实现进程间的互斥与同步，并非用于存储进程间通信数据，若要传递数据需结合共享内存。PV原语操作用于同一进程实现各线程的互斥，不同进程实现同步；
- 共享内存，共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。两个进程通过页表映射到同一片物理地址，shmat函数将进程连接到贡献内存
- socket，可用于不同机器间的进程通信

7. 线程之间的通信
  启动一个进程必须分配独立的地址空间，建立众多的数据表维护它的代码段，堆栈段和数据段。线程之间的切换代价远小于进程切换，线程之间方便的通信机制。
- 互斥锁，是一种信号量，防止两个线程在同一时刻访问相同的共享资源，锁必须是同一个线程获取释放；
- 条件变量，线程阻塞，等待另一个线程发送信号；
- 信号量，一个计数器，调用一次wait，信号量减1，如果信号量为0，wait操作阻塞，post信号量加1，信号量可以被多个线程PV操作；

8. 匿名管道如何实现进程间通信？
  （1）父进程创建管道pipe，得到两个文件描述符指向管道的读端和写端；
  （2）父进程fork子进程，子进程也有两个相同的文件描述符；
  （3）父进程关闭读端fd[0]，子进程关闭写端fd[1]，数据从父进程流向子进程；
  ![Pipe](/images/20190830/ipc_pipe.png){:	.align-center}

9. 死锁的四大条件
- 互斥，对资源进行排他性控制，仅为一个进程占有；
- 占有并等待，如果一个进程持有某一资源，又提出对其他资源的请求，而该资源被其他进程占有，此时进程阻塞，但不释放已获得的资源；
- 不可抢占，进程获得的资源在释放之前不能被其他进程强行抢占；
- 循环等待，