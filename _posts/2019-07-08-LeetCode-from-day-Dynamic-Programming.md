---
layout: post
title: '[LeetCode From Day One] - Tips and Tricks in Dynamic Programming'
author: Marty Pang
categories: 
  - Algorithm
tags: 
  - LeetCode
  - Dynamic Programming
last_modified_at: 2019-07-10T16:31:21-05:00
---

动态规划与回溯一样，作为五大重用算法之一，几乎是是笔试面试必考的内容。首先要明确的是，动态规划不是算法，而是设计算法的一种方法。DP解决的问题是一个多阶段决策问题，每阶段面临多个决策，选择最优决策达到下一状态，直至终态。DP则是在状态转移的过程中寻找最优解。本文总结动态规划问题的一些特征以及解决动态规划问题的过程。


* 目录
{:toc}


# 动态规划问题的特征

动态规划的核心是把原问题划分为子问题进行求解，这些问题有如下几个特征，包括最优子结构、子问题重叠、边界和无后效性。这几个看起来很高大上的名词，其实结合具体问题来看就是非常容易理解的。

1. 最优子结构
在得到子问题最优解的前提下，母问题再通过一定的优化即可得到最优解。

2. 子问题重叠
即子问题之间是不独立的，一个子问题的解可能在其他子问题求解过程中使用。这一点其实不算动态规划的必有的特征，但是如果子问题均是独立的，动态规划算法优势体现不出。例如在斐波那契的例子中，计算`F(4)=F(3)+F(2)`，得到子问题`F(3)`和`F(2)`。假设我们得到了子问题`F(2)`的 结果，那么在计算子问题`F(3)`时，直接使用其结果即可，无需重复计算。

3. 边界
这个特性最容易理解，在一定时候不再需要提出子问题的情况叫做边界。例如斐波那契数列的边界为`F(0)`和`F(1)`。

4. 无后效性
即某阶段的状态一旦确定，就不受之后的决策影响。换句话说，某状态至于当前状态有关，不影响之前状态。例如`F(4)`的计算并不会影响`F(0)`的结果。

## 模型
动态规划的经典模型有线性模型、区间模型、背包模型、状态压缩模型和树形模型。这部分内容可参考mmc2015的[动态规划总结](https://blog.csdn.net/mmc2015/article/details/73558346)，这里仅做简单引用。

1. 线性
线性模型是DP中最常见的模型，线性指的是状态的排布是线性的，时间上或者空间上。

2. 区间
区间模型的状态一般由`d[i][j]`表示

3. 背包
4. 树状

# 解决动态规划问题

## top-down

自顶向下的做法其实是带记忆的递归解法（记忆化搜索）。也就是，我们首先考虑从最终状态出发，如果遇到一个子问题还未求解，那么就先求解子问题。一般用于解决树状模型的DP问题，从父节点出发找到所有的子问题，确定子问题之间传递的参数。仍旧以最简单的斐波那契为例，使用自顶向下的解法，代码如下：

```java
int fibonacci(int n, int[] f) {
    if(n == 0) {
        f[0] = 1;
        return f[0]
    }
    if(n == 1) {
        f[1] = 1;
        return f[1];
    }
    if(f[n] != 0) { // -1表示状态n未被计算过
        return f[n];
    } else {
        f[n] = fibonacci(n-1, f) + fibonacci(n-2, f);
        return f[n];
    }
}
```

## bottom-up

# LeetCode动态规划题解
139 word break、279 perfect squares 、300 LIS找到某个j